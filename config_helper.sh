#! /bin/sh
# This script is invoked by some Makefile rules.
#
# (c) 2013 by Guenther Brunthaler <gb_about_gnu@gmx.net>.
#
# This script is free software.
# Distribution is permitted under the terms of the LGPLv3.


die() {
	echo "ERROR: $*" >& 2
	false; exit
}


run() {
	"$@" && return
	die "Command >>>$*<<< failed with return code ${?}!"
}


system() {
	REPLY=`run "$@"` || exit
}


header() {
	run echo "# AUTOGENERATED FILE - DO NOT EDIT!"
	run echo "# Generated by ${0##*/} on `LC_ALL=C date`."
	run echo
}


have_exe() {
	which -- "$1" > /dev/null 2>& 1
}


require() {
	test -f "$1" || die "Missing required file '$1'!"
}


# Just touch the existing file; don't try to regenerate it.
# Does not return but rather exits the script after this.
fake() {
	require "$1"
	run touch -- "$1"
	exit
}


repo_update_only() {
	test -n "$HAVE_BZR" && return
	fake "$1"
}


realpath() {
	system readlink -f -- "$1"
}


print() {
	run printf "%s\n" "$*"
}


enum_exports() {
	WSA="\($WS\|[*]\)"
	run sed -e "
		s/^$WS*extern$WS.*$WSA\($ID\)$WS*[([;].*/\2 $1/
		t
		d
	"
}


enum_tokens() {
	run sed -e "s/$NID/ /g" | while read line
	do
		for token in $line
		do
			print "$token $1"
		done
	done
}


enum_includes() {
	run sed -e "
		s!^$WS*#include$WS*<\([^>/]\+\)>.*!\1!; t
		s!^$WS*#include$WS*\"\([^\"/]\+\)\".*!\1!; t
		d
	" | while IFS= read -r line
	do
		print "$line $1"
	done
}


enum_known_ignores() {
	run cat <<- .
		config.h
.
}


usort() {
	LC_ALL=C run sort -u -- "$@"
}


ljoin() {
	LC_ALL=C run join "$@"
}


to_ident() {
	run printf '%s' "$1" | tr -c A-Za-z0-9_ _
}


cleanup() {
	set -- $tfs
	for tf
	do
		rm "$tf"
	done
}


tfs=
trap cleanup 0
if test ! -f config_helper.sh || test ! -f autogen.sh
then
	die "Must be called from top-level source directory!"
fi
# Check whether version control tool is available.
HAVE_BZR=; test -d .bzr && have_exe bzr && HAVE_BZR=Y
# Options used internally by Makefile_am.in.
case $1 in
	--makefile-header)
		header
		> provides.tmp; tfs="$tfs provides.tmp"
		> uses.tmp; tfs="$tfs uses.tmp"
		> apps.tmp; tfs="$tfs apps.tmp"
		> src.tmp; tfs="$tfs src.tmp"
		> implicit.tmp; tfs="$tfs implicit.tmp"
		> anywhere.tmp; tfs="$tfs anywhere.tmp"
		system printf '[\t ]'; WS=$REPLY
		ID='[A-Za-z_][A-Za-z_0-9]*'
		NID='[^A-Za-z_0-9][0-9]*'
		for SRC in *.c *.cpp *.C *.cxx *.c++
		do
			test -f "$SRC" || continue
			print "$SRC" >> src.tmp
			if
				test -f "$SRC" \
					&& grep '^\s*int\s\+main\s*[(]' \
						> /dev/null 2>& 1 -- "$SRC"
			then
				# Application source file.
				print "$SRC" >> apps.tmp
			else
				# Supplemental / library source file.
				enum_exports "$SRC" < "$SRC" >> provides.tmp
			fi
			enum_tokens "$SRC" < "$SRC" >> uses.tmp
			enum_includes "$SRC" < "$SRC" >> uses.tmp
		done
		for SRC in *.h *.hpp *.hxx *.h++ *.inl
		do
			test -f "$SRC" || continue
			print "$SRC" >> src.tmp
			print "$SRC $SRC" >> provides.tmp
			enum_includes "$SRC" < "$SRC" >> uses.tmp
		done
		echo "bin_PROGRAMS = \\"
		system printf '\tx'; TAB=${REPLY%?}
		run cat apps.tmp > sort.tmp; tfs="$tfs sort.tmp"
		usort sort.tmp > apps.tmp
		while IFS= read -r SRC
		do
			print "${SRC%.*}"
		done < apps.tmp \
		| run sed -e "s/^/$TAB/; s/$/ \\\\/"
		echo "$TAB#"
		f=ignore_sources.lst
		test -f "$f" && run cat "$f" >> implicit.tmp
		enum_known_ignores >> implicit.tmp
		usort implicit.tmp > sort.tmp
		run cat sort.tmp > implicit.tmp
		run cat uses.tmp > sort.tmp
		usort sort.tmp > uses.tmp
		run cat provides.tmp > sort.tmp
		usort sort.tmp > provides.tmp
		run cat src.tmp > sort.tmp
		usort sort.tmp > src.tmp
		tfs="$tfs deps.tmp"
		ljoin provides.tmp uses.tmp | \
		while read SYM NEEDED BY
		do
			test x"$NEEDED" = x"$BY" && continue
			print "$BY $NEEDED"
		done | usort > deps.tmp
		tfs="$tfs needed.tmp imm.tmp"
		while read SRC
		do
			# Start with top-level dependency.
			print "$SRC -1" > needed.tmp
			L=-2
			while :
			do
				# Find immediate dependencies of needed.tmp.
				ljoin -o 2.2 needed.tmp deps.tmp \
				| usort > imm.tmp
				# Remove dependencies already in needed.tmp.
				ljoin -v2 needed.tmp imm.tmp \
				| sed -e "s/$/ $L/" > sort.tmp
				# Stop if no new dependencies were found.
				test ! -s sort.tmp && break
				run cat needed.tmp >> sort.tmp
				usort sort.tmp > needed.tmp
				L=`expr $L - 1`
			done
			ljoin -v1 needed.tmp implicit.tmp > sort.tmp
			test -s sort.tmp || continue
			run cat sort.tmp > needed.tmp
			if
				# Suppress "xxx_SOURCES = xxx.c" lines.
				system wc -l needed.tmp
				test x"$REPLY" != x1 \
				|| test x"$SRC{##*.}" != x"c"
			then
				system to_ident "${SRC%.c}"
				echo "${REPLY}_SOURCES = \\"
				LC_ALL=C run sort -k2n -k1 needed.tmp \
				| run cut -d" " -f1 \
				| run sed -e "s/^/$TAB/; s/$/ \\\\/"
				echo "$TAB#"
			fi
			run cat needed.tmp anywhere.tmp > sort.tmp
			usort sort.tmp > anywhere.tmp
		done < apps.tmp
		run echo
		ljoin -v1 src.tmp implicit.tmp > sort.tmp
		run cat sort.tmp > src.tmp
		ljoin -v2 anywhere.tmp src.tmp > sort.tmp
		if test -s sort.tmp
		then
			u="UNUSED_SOURCES.txt"
			run sort sort.tmp > "$u"
			run echo "*** Warning: The following source files" \
				"are UNUSED:"
			run sed -e 's,^,",; s,$,",' "$u"
			run echo "(End of list.)"
			run echo "The list of unused files" \
				"has been saved as file '$u'."
		fi >& 2
		;;
	--expand-configure-ac)
		TEMPLATE=$2
		VERSIONFILE=$3
		header
		system cat "$VERSIONFILE"; VER=$REPLY
		test -n "$VER" || die "Missing version information!"
		run sed -e 's,@69r83a0k7ji8x8tlyy2wu6s48@,'"$VER"',g' \
			< "$TEMPLATE"
		;;
	--detect-version)
		FILE=$2
		repo_update_only "$FILE"
		system pwd
		realpath "$REPLY"; CDIR=$REPLY
		system bzr root
		realpath "$REPLY"
		test x"$CDIR" != x"$REPLY" && fake "$FILE"
		system bzr revno; CURR_VER=$REPLY
		system printf '\t '; WS=$REPLY
		run bzr tags | run awk '
			BEGIN { best_ver= "0.1"; latest_rev= 0; }
			$2 ~ /^[0-9]+$/ {
				if ($2 <= '"$CURR_VER"' && $2 >= latest_rev) {
					latest_rev= $2;
					best_ver= $1;
				}
			}
			END { print(best_ver); }
		' > "$FILE"
		;;
	--update-changelog)
		FILE=$2
		repo_update_only "$FILE"
		{
			bzr log --gnu || run bzr log --short
		} > "$FILE" 2> /dev/null
		;;
	--update-news)
		FILE=$2
		repo_update_only "$FILE"
		run bzr log --long -r last:1 \
			| run sed -e '
				0,/^message:$/ !b
				s/^mess.*//
				t
				/^tags\|time/ !d
			' \
			| run fmt -p "  " -w 77 \
			| run sed -e 's,^ *,,' > "$FILE"
		;;
	*)
		die "Unsupported command '$1'!"
esac
